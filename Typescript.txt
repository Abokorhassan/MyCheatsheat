// Cheat Sheet

// Annotation
let sales: number = 123_456_789;
let numbers: number[] = [1, 2, 3];

// Tuples;
let user: [number, string] = [1, "Abokor"];

// Enums;
enum Size {
  Small = 1,
  Medium,
  Large,
}

// Functions;
function calculateTax(income: number): number {
  return income * 0.2;
}

// Objects;
let employee: {
  id: number;
  name: string;
  retire: (date: Date) => void;
} = {
  id: 1,
  name: "Abokor",
  retire: (date: Date) => {},
};

// Compiler Options
Option                 Description
noImplicitAny:          When enabled, the compiler will warn you about variables that are inferred with the any type. You’ll then have to explicitly annotate them with any if you have a reason to do so.
noImplicitReturns:      When enabled, the compiler will check all code paths in a function to ensure they return a value.
noUnusedLocals:         When enabled, the compiler will report unused local variables.
noUnusedParameters:     When enabled, the compiler will report unused parameters.

// Type alias
type Employee = {
  id: number;
  name: string;
  retire: (date: Date) => void;
};

// Union types
let weight: number | string = 1;
weight = "1kg";

// Intersection types
type UIWidget = Draggable & Droppable;

// Literal types
type Quantity = 50 | 100;

// Nullable types
let name: string | null = null;

// Optional chaining (?.)
customer?.birthdate?.getFullYear();
customers?.[0];
log?.("message");

// Nullish coalescing operator
someValue ?? 30 

// Type assertion
obj as Person 

// The unknown type
function render(document: unknown) {
// We have to narrow down to a specific
// type before we can perform any operations // on an unknown type.
if (typeof document === 'string') {
} }

// The never type
function processEvents(): never {
// This function never returns because // it has an infinite loop.
while (true) {}
}


// Compiler Options
Option                    Description
strictNullChecks:            When enabled, null and undefined will not be acceptable values for variables unless you explicitly declare them as nullable. So, you’ll get an error if you set a variable to null or undefined.
allowUnreachableCode:        When set the false, reports error about unreachable code.


// Classes and constructors
class Account {
  id: number;
  constructor(id: number) { 
    this.id = id;
  } 
}
let account = new Account(1); 

// Accessing properties and methods
account.id = 1; 
account.deposit(10);

// Read-only and optional properties
class Account {
  readonly id: number;
  nickname?: string;
}

// Access modifiers
class Account {
  private _balance: number;
  // Protected members are inherited.
  // Private members are not.
  protected _taxRate: number;
}

// Parameter properties
class Account {
  // With parameter properties we can
  // create and initialize properties in one place.
  constructor(public id: number, private _balance: number) {
  }
}

// Getters and setters
class Account {
  private _balance = 0;
  get balance(): number { 
    return this._balance;
  }
  set balance(value: number) { 
    if (value < 0)
    throw new Error(); this._balance = value;
  }
}

// Index signatures
class SeatAssignment {
  // With index signature properties we can add
  // properties to an object dynamically
  // without losing type safety.
  [seatNumber: string]: string;
}
let seats = new SeatAssignment(); seats.A1 = 'Mosh';
seats.A2 = 'John';

// Static members
class Ride {
  static activeRides = 0;
}
Ride.activeRides++;

// Inheritance
class Student extends Person {
}

// Method overriding
class Student extends Person { 
  override speak() {
    console.log('Student speaking'); 
  }
}

// Abstract classes and methods
abstract class Shape {
// Abstract methods don't have a body abstract render();
}
class Circle extends Shape { 
  override render() {
    console.log('Rendering a circle'); 
  }
}

// Interfaces
interface Calendar { 
  name: string; 
  addEvent(): void;
}
class GoogleCalendar implements Calendar {
}


// Compiler Options
Option                     Description
noImplicitOverride          tWhen enabled, then compiler will warn us if we try to override a method without using the override keyword.

// Generic classes
class KeyValuePair<K, V> {
  constructor(public key: K, public value: V) {}
}
let pair = new KeyValuePair<number, string>(1, 'a');

// The TypeScript compiler can sometimes infer
// generic type arguments so we don't need to specify them. 
let other = new KeyValuePair(1, 'a');

// Generic functions
function wrapInArray<T>(value: T) { 
    return [value];
}
let numbers = wrapInArray(1);

// Generic interfaces
interface Result<T> {
  data: T | null;
}

// Generic constraints
function echo<T extends number | string>(value: T) {}
function echo<T extends { name: string }>(value: T) {}  // Restrict using a shape object
function echo<T extends Person>(value: T) {} // Restrict using an interface or a class


// Extending generic classes
// Passing on generic type parameters
class CompressibleStore<T> extends Store<T> { }

// Constraining generic type parameters
class SearchableStore<T extends { name: string }> extends Store<T> { }

// Fixing generic type parameters
class ProductStore extends Store<Product> { }


// The keyof operator
interface Product {
  name: string;
  price: number;
}
let property: keyof Product;
// Same as
let property: 'name' | 'price';
property = 'name';
property = 'price';
property = 'otherValue'; // Invalid


// Type mapping
type ReadOnly<T> = {
  readonly [K in keyof T]: T[K];
};
type Optional<T> = {
  [K in keyof T]?: T[K];
};
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};


// Utility types
interface Product {
  id: number;
  name: string;
  price: number;
}
// A Product where all properties are optional
let product: Partial<Product>;
// A Product where all properties are required
let product: Required<Product>;
// A Product where all properties are read-only
let product: Readonly<Product>;
// A Product with two properties only (id and price)
let product: Pick<Product, 'id' | 'price'>;
// A Product without a name
let product: Omit<Product, 'name'>;

// Class decorators
function Component(constructor: Function) {
  // Here we have a chance to modify members of 
  // the target class. 
  constructor.prototype.uniqueId = Date.now();
} 
@Component
class ProfileComponent { }

// Parameterized decorators
function Component(value: number) { 
  return (constructor: Function) => {
  // Here we have a chance to modify members of 
  // the target class. 
  constructor.prototype.uniqueId = Date.now();
  }; 
}

@Component(1)
class ProfileComponent {}

// Decorator composition
// Multiple decorators are applied in reverse order.
// Pipe followed by Component.
@Component
@Pipe
class ProfileComponent {}

// Method decorators
function Log(target: any, methodName: string, descriptor: PropertyDescriptor) {
  // We get a reference to the original method
  const original = descriptor.value as Function; 
  // Then, we redefine the method 
  descriptor.value = function(...args: any) {
    // We have a chance to do something first
    console.log('Before');
    // Then, we call the original method 
    original.call(this, ...args);
    // And we have a chance to do something after 
    console.log('After'); 
  } 
}
class Person {
  @Log
  say(message: string) {} 
}


// Accessor decorators
function Capitalize(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const original = descriptor.get; 
  descriptor.get = function() {
    const result = original.call(this);
    return 'newResult';
  }
}

class Person { 
  @Capitalize
  get fullName() {}
}

// Property decorators
function MinLength(length: number) {
  return (target: any, propertyName: string) => {
    // We use this variable to hold the value behind the
    // target property.
    let value: string;
     // We create a descriptor for the target property.
    const descriptor: PropertyDescriptor = {
      // We're defining the setter for the target property. 
      set(newValue: string) {
        if (newValue.length < length) throw new Error();
          value = newValue;
      }
  }
  // And finally, we redefine the property.
  Object.defineProperty(target, propertyName, descriptor); }
}
class User { @MinLength(4) password: string;
}

// Exporting and importing
// shapes.ts
export class Circle {}
export class Square {}
// app.ts
import { Circle, Square as MySquare } from './shapes'; 

// Default exports
// shapes.ts
export default class Circle {}
// app.ts
import Circle from './shapes'; 

// Wildcard imports
// app.ts
import * as Shapes from './shapes'; let circle = new Shapes.Circle();

// Re-exporting
// /shapes/index.ts
export { Circle } from './circle';
export { Square } from './square';
// app.ts
import { Circle, Square } from './shapes';