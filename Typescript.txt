// Cheat Sheet

// Annotation
let sales: number = 123_456_789;
let numbers: number[] = [1, 2, 3];

// Tuples;
let user: [number, string] = [1, "Abokor"];

// Enums;
enum Size {
  Small = 1,
  Medium,
  Large,
}

// Functions;
function calculateTax(income: number): number {
  return income * 0.2;
}

// Objects;
let employee: {
  id: number;
  name: string;
  retire: (date: Date) => void;
} = {
  id: 1,
  name: "Abokor",
  retire: (date: Date) => {},
};

// Compiler Options
Option                 Description
noImplicitAny:          When enabled, the compiler will warn you about variables that are inferred with the any type. You’ll then have to explicitly annotate them with any if you have a reason to do so.
noImplicitReturns:      When enabled, the compiler will check all code paths in a function to ensure they return a value.
noUnusedLocals:         When enabled, the compiler will report unused local variables.
noUnusedParameters:     When enabled, the compiler will report unused parameters.

// Type alias
type Employee = {
  id: number;
  name: string;
  retire: (date: Date) => void;
};

// Union types
let weight: number | string = 1;
weight = "1kg";

// Intersection types
type UIWidget = Draggable & Droppable;

// Literal types
type Quantity = 50 | 100;

// Nullable types
let name: string | null = null;

// Optional chaining (?.)
customer?.birthdate?.getFullYear();
customers?.[0];
log?.("message");

// Nullish coalescing operator
someValue ?? 30 

// Type assertion
obj as Person 

// The unknown type
function render(document: unknown) {
// We have to narrow down to a specific
// type before we can perform any operations // on an unknown type.
if (typeof document === 'string') {
} }

// The never type
function processEvents(): never {
// This function never returns because // it has an infinite loop.
while (true) {}
}


// Compiler Options
Option                    Description
strictNullChecks:            When enabled, null and undefined will not be acceptable values for variables unless you explicitly declare them as nullable. So, you’ll get an error if you set a variable to null or undefined.
allowUnreachableCode:        When set the false, reports error about unreachable code.


// Classes and constructors
class Account {
  id: number;
  constructor(id: number) { 
    this.id = id;
  } 
}
let account = new Account(1); 

// Accessing properties and methods
account.id = 1; 
account.deposit(10);

// Read-only and optional properties
class Account {
  readonly id: number;
  nickname?: string;
}

// Access modifiers
class Account {
  private _balance: number;
  // Protected members are inherited.
  // Private members are not.
  protected _taxRate: number;
}

// Parameter properties
class Account {
  // With parameter properties we can
  // create and initialize properties in one place.
  constructor(public id: number, private _balance: number) {
  }
}

// Getters and setters
class Account {
  private _balance = 0;
  get balance(): number { 
    return this._balance;
  }
  set balance(value: number) { 
    if (value < 0)
    throw new Error(); this._balance = value;
  }
}

// Index signatures
class SeatAssignment {
  // With index signature properties we can add
  // properties to an object dynamically
  // without losing type safety.
  [seatNumber: string]: string;
}
let seats = new SeatAssignment(); seats.A1 = 'Mosh';
seats.A2 = 'John';

// Static members
class Ride {
  static activeRides = 0;
}
Ride.activeRides++;

// Inheritance
class Student extends Person {
}

// Method overriding
class Student extends Person { 
  override speak() {
    console.log('Student speaking'); 
  }
}

// Abstract classes and methods
abstract class Shape {
// Abstract methods don't have a body abstract render();
}
class Circle extends Shape { 
  override render() {
    console.log('Rendering a circle'); 
  }
}

// Interfaces
interface Calendar { 
  name: string; 
  addEvent(): void;
}
class GoogleCalendar implements Calendar {
}


// Compiler Options
Option                     Description
noImplicitOverride          When enabled, then compiler will warn us if we try to override a method without using the override keyword.